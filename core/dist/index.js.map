{"version":3,"sources":["../src/utils/uuid.ts","../src/index.ts"],"sourcesContent":["const uuid = () => [...Array(4)].map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join('-')\n\nexport default uuid\n","import uuid from '@/utils/uuid'\n\nexport interface Message {\n  type: 'apply'\n  id: string\n  path: string[]\n  sender: 'import' | 'export'\n  callbackIds?: string[]\n  args: any[]\n  error?: string\n  data?: any\n}\n\nexport interface Adapter {\n  onMessage: (callback: (message: Message) => void) => void\n  sendMessage: (message: Message) => void\n}\n\nconst createExport = <T extends Record<string, any>>(target: T, adapter: Adapter) => {\n  adapter.onMessage(async (_message) => {\n    if (_message.sender !== 'import') return\n\n    const message: Message = {\n      ..._message,\n      sender: 'export'\n    }\n\n    switch (_message.type) {\n      case 'apply': {\n        const mapArgs = _message.args.map((arg) => {\n          if (_message.callbackIds?.includes(arg)) {\n            return (...args: any[]) => {\n              adapter.sendMessage({\n                ..._message,\n                id: arg,\n                data: args,\n                sender: 'export'\n              })\n            }\n          } else {\n            return arg\n          }\n        })\n        try {\n          message.data = await (_message.path.reduce((acc, key) => acc[key], target) as unknown as Function).apply(\n            target,\n            mapArgs\n          )\n        } catch (error) {\n          message.error = (error as Error).message\n        }\n        break\n      }\n    }\n\n    adapter.sendMessage(message)\n  })\n}\n\nconst createImport = <T extends Record<string, any>>(context: T, adapter: Adapter) => {\n  const createProxy = (target: T, path: string[]) => {\n    const proxy = new Proxy<T>(target, {\n      get(_target, key: string) {\n        return createProxy((() => {}) as unknown as T, [...path, key] as string[])\n      },\n      apply(_target, _thisArg, args) {\n        return new Promise<Message>((resolve, reject) => {\n          try {\n            const callbackIds: string[] = []\n\n            const mapArgs = args.map((arg) => {\n              if (typeof arg === 'function') {\n                const callbackId = uuid()\n                callbackIds.push(callbackId)\n                adapter.onMessage((_message) => {\n                  if (_message.sender !== 'export') return\n                  if (_message.id !== callbackId) return\n                  arg(..._message.data)\n                })\n                return callbackId\n              } else {\n                return arg\n              }\n            })\n            const message: Message = {\n              type: 'apply',\n              id: uuid(),\n              path,\n              sender: 'import',\n              callbackIds,\n              args: mapArgs\n            }\n\n            adapter.onMessage((_message) => {\n              if (_message.sender !== 'export') return\n              if (_message.id !== message.id) return\n\n              _message.error ? reject(new Error(_message.error)) : resolve(_message.data)\n            })\n            adapter.sendMessage(message)\n          } catch (error) {\n            reject(error)\n          }\n        })\n      }\n    })\n    return proxy\n  }\n  return createProxy(context, [])\n}\n\nconst exportProxy =\n  <T extends Record<string, any>>(context: (...args: any[]) => T, adapter: Adapter) =>\n  <A>(...args: A[]) => {\n    return createExport(context(...args), adapter)\n  }\n\nconst importProxy =\n  <T extends Record<string, any>>(_: (...args: any[]) => T, adapter: Adapter) =>\n  () => {\n    return createImport((() => {}) as unknown as T, adapter)\n  }\n\nconst defineProxy = <T extends Record<string, any>>(context: () => T, adapter: Adapter) => {\n  return [exportProxy(context, adapter), importProxy(context, adapter)] as const\n}\n\nexport default defineProxy\n"],"mappings":"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","names":[]}